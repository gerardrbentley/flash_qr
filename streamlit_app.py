import io
import streamlit as st
import qrcode
from qrcode.image.styledpil import StyledPilImage
from qrcode.image.styles.moduledrawers import (
    RoundedModuleDrawer,
    SquareModuleDrawer,
    GappedSquareModuleDrawer,
    CircleModuleDrawer,
    VerticalBarsDrawer,
    HorizontalBarsDrawer,
)
from qrcode.image.styles.colormasks import (
    SolidFillColorMask,
    ImageColorMask,
    RadialGradiantColorMask,
    SquareGradiantColorMask,
    VerticalGradiantColorMask,
    HorizontalGradiantColorMask,
)
from qrcode.constants import (
    ERROR_CORRECT_L,
    ERROR_CORRECT_M,
    ERROR_CORRECT_Q,
    ERROR_CORRECT_H,
)
from streamlit_cropper import st_cropper
from PIL import Image

st.header("Flash QR")
st.write(
    "Generate Unique QR Codes For Your Project / Business.\n\nFind advanced customization in the sidebar to the left"
)

with st.expander("Learn More:"):
    st.write(
        """\n
QR Codes are great for linking to a website / signup / payment URL.

Google and Meta (among others) use their own custom style of QR codes generated by Chrome and Instagram to advertise their products.

But you should be advertising your own brand / business!

Make it easy to create QR codes with this tool made with ❤️ by [Gar's Bar](https://gerardbentley.com) and powered by [Streamlit](https://streamlit.io) and Python `qrcode` [library](https://github.com/lincolnloop/python-qrcode).
"""
    )


def hex_to_tuple(hex: str) -> tuple:
    if hex.startswith("#"):
        hex = hex[1:]
    r, g, b = bytes.fromhex(hex)
    return (r, g, b)


website_url = st.text_input("URL for QR Code:", "https://gerardbentley.com")
dot_mapping = {
    "square": SquareModuleDrawer,
    "square with gaps": GappedSquareModuleDrawer,
    "round": RoundedModuleDrawer,
    "circle": CircleModuleDrawer,
    "vertical bars": VerticalBarsDrawer,
    "horizontal bars": HorizontalBarsDrawer,
}
dot_style = st.sidebar.radio("QR Box Style", dot_mapping)
qr_version = st.sidebar.slider(
    "QR Boxes", 1, 40, 8, help="QR Code version defines how many boxes across minimum"
)
box_size = st.sidebar.number_input("QR Box Size", 1, 100, 10)
border_boxes = st.sidebar.number_input("QR Border Boxes", 1, 100, 4)
error_mapping = {
    "~7%": ERROR_CORRECT_L,
    "~15%": ERROR_CORRECT_M,
    "~25%": ERROR_CORRECT_Q,
    "~30%": ERROR_CORRECT_H,
}
error_correction = st.sidebar.radio("Error Leniency", error_mapping, index=3)

mask_mapping = {
    "Solid Colors": SolidFillColorMask,
    "Radial Gradient": RadialGradiantColorMask,
    "Square Gradient": SquareGradiantColorMask,
    "Vertical Gradient": VerticalGradiantColorMask,
    "Horizontal Gradient": HorizontalGradiantColorMask,
    "Background From Image": ImageColorMask,
}
mask_choice = st.sidebar.radio("QR Color Mask", mask_mapping)
mask_cls = mask_mapping[mask_choice]
mask_kwargs = {}

back_color_hex = st.sidebar.color_picker(
    label="QR Background Color", value="#FFFFFF", key="back"
)
mask_kwargs["back_color"] = hex_to_tuple(back_color_hex)

if mask_cls == SolidFillColorMask:
    front_color_hex = st.sidebar.color_picker(label="QR Fill Color", value="#000000")
    mask_kwargs["front_color"] = hex_to_tuple(front_color_hex)

if mask_cls in (RadialGradiantColorMask, SquareGradiantColorMask):
    center_color_hex = st.sidebar.color_picker(
        label="QR Center Color", value="#1CB5E0", key="center"
    )
    mask_kwargs["center_color"] = hex_to_tuple(center_color_hex)

if mask_cls in (RadialGradiantColorMask, SquareGradiantColorMask):
    edge_color_hex = st.sidebar.color_picker(
        label="QR Edge Color", value="#000047", key="edge"
    )
    mask_kwargs["edge_color"] = hex_to_tuple(edge_color_hex)

if mask_cls == VerticalGradiantColorMask:
    top_color_hex = st.sidebar.color_picker(
        label="QR Top Color", value="#1CB5E0", key="top"
    )
    mask_kwargs["top_color"] = hex_to_tuple(top_color_hex)

if mask_cls == VerticalGradiantColorMask:
    bottom_color_hex = st.sidebar.color_picker(
        label="QR Bottom Color", value="#000047", key="bot"
    )
    mask_kwargs["bottom_color"] = hex_to_tuple(bottom_color_hex)

if mask_cls == HorizontalGradiantColorMask:
    left_color_hex = st.sidebar.color_picker(
        label="QR Left Color", value="#1CB5E0", key="top"
    )
    mask_kwargs["left_color"] = hex_to_tuple(left_color_hex)

if mask_cls == HorizontalGradiantColorMask:
    right_color_hex = st.sidebar.color_picker(
        label="QR Right Color", value="#000047", key="bot"
    )
    mask_kwargs["right_color"] = hex_to_tuple(right_color_hex)

aspect_dict = {
    "1:1": (1, 1),
    "16:9": (16, 9),
    "4:3": (4, 3),
    "2:3": (2, 3),
    "Free": None,
}
# Decide how the User will provide an image
use_upload = "Upload an Image"
use_camera = "Use Camera to take a Photo"
no_image = "No Image"

if mask_cls == ImageColorMask:
    st.sidebar.info("Choose a Background Image and crop it in the center menu")
    background_image_method = st.radio(
        "Image for Background of QR Code:", [use_upload, use_camera]
    )

    if background_image_method == use_upload:
        qr_background_image_file = st.file_uploader(
            "Upload Image File for background of QR 🌄",
            ["png", "jpg", "jpeg"],
            accept_multiple_files=False,
            key="qr_background_image_uploader",
        )
    elif background_image_method == use_camera:
        qr_background_image_file = st.camera_input(
            "Take a Photo for background of QR 📸", key="qr_background_image_photo"
        )
    background_crop_box_color = st.sidebar.color_picker(
        label="Background Crop Box Color",
        value="#FF0000",
        key="background_crop_box_color",
    )
    background_aspect_choice = st.sidebar.radio(
        label="Background Crop Aspect Ratio",
        options=aspect_dict.keys(),
        key="background_aspect_choice",
    )
    if qr_background_image_file is not None:
        try:
            st.success("Will use this image for center of the QR. Crop as needed")
            background_image = Image.open(qr_background_image_file)
            cropped_background = st_cropper(
                background_image,
                realtime_update=True,
                box_color=background_crop_box_color,
                aspect_ratio=aspect_dict[background_aspect_choice],
                key="cropped_background",
            )
            with st.expander("Show cropped image"):
                st.image(cropped_background)
            mask_kwargs["color_mask_image"] = cropped_background
        except Exception as e:
            print(e)
            st.error(
                "Could not use uploaded image for center of QR 😢\nTry another image or no image."
            )
            st.stop()
    else:
        st.warning("Choose / take a photo to continue")
        st.stop()


image_method = st.radio(
    "Image in Center of QR Code:", [no_image, use_upload, use_camera]
)

if image_method == use_upload:
    image_file = st.file_uploader(
        "Upload Image File for center of QR 🌄",
        ["png", "jpg", "jpeg"],
        accept_multiple_files=False,
        key="image_file_upload",
    )
elif image_method == use_camera:
    image_file = st.camera_input(
        "Take a Photo for center of QR 📸", key="image_file_photo"
    )
elif image_method == no_image:
    image_file = None

cropped_img = None
if image_method in (use_camera, use_upload):
    crop_box_color = st.sidebar.color_picker(
        label="Center Image Crop Box Color", value="#FF0000", key="crop_box_color"
    )
    aspect_choice = st.sidebar.radio(
        label="Center Image Crop Aspect Ratio",
        options=["1:1", "16:9", "4:3", "2:3", "Free"],
        key="aspect_choice",
    )

    if image_file is not None:
        try:
            st.success("Will use this image for center of the QR. Crop as needed")
            embeded_image = Image.open(image_file)
            cropped_img = st_cropper(
                embeded_image,
                realtime_update=True,
                box_color=crop_box_color,
                aspect_ratio=aspect_dict[aspect_choice],
                key="cropped_img",
            )
            with st.expander("Show cropped center image"):
                st.image(cropped_img)
        except Exception as e:
            print(e)
            st.error(
                "Could not use uploaded image for center of QR 😢\nTry another image or no image."
            )
            st.stop()
    else:
        st.warning("Choose / take a photo to continue")
        st.stop()


qr = qrcode.QRCode(
    version=qr_version,
    error_correction=error_mapping[error_correction],
    box_size=box_size,
    border=border_boxes,
)
qr.add_data(website_url)
qr.make(fit=True)

img = qr.make_image(
    color_mask=mask_cls(**mask_kwargs),
    image_factory=StyledPilImage,
    module_drawer=dot_mapping[dot_style](),
    embeded_image=cropped_img,
)

with io.BytesIO() as output:
    img.save(output, format="png")
    contents = output.getvalue()
    btn = st.download_button(
        label="Download QR Code",
        data=output,
        file_name="qr.png",
        mime="image/png",
    )
st.subheader("QR Code Preview")
st.image(contents)
st.sidebar.write("")
